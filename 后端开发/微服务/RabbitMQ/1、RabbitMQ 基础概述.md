# 1、MQ的相关概念

## 1.1、什么是MQ

​	`MQ(message queue)` ，从字面意思上看本质是一个队列，遵循 `FIFO` 先进先出原则，只不过队列中存放的内容是 `message` 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中， `MQ` 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用 `MQ` 之后，消息发送上游只需要依赖 `MQ` ，不用依赖其他服务。

## 1.2、为什么要使用 `MQ` 

### 1.2.1、流量消峰

​	若一个系统一秒最多能处理一万次订单，但当超过这个阈值时系统将会无法处理多余的订单，导致系统宕机或拒绝订单。当使用消息队列进行缓冲后，可以将这高峰期一秒的订单分散一段时间进行处理，给系统有足够的时间进行处理订单。

### 1.2.2、应用解耦

​	以电商系统为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，其中如果有任何一个子系统故障，都会导致订单异常。当使用消息队列后，当某一个子系统发生故障时，子系统需要处理的内容就会被缓存在消息队列中，等待故障的子系统恢复即可继续完成订单。

### 1.2.3、异步处理

​	有些服务之间的调用是异步进行的，一般有两种解决方法，一是调用方轮询被调用方是否执行完毕，二是被调用方访问调用方的 `callback api` 。在使用消息总线后，`MQ` 会监听被调用方是否执行完毕，完成后 `MQ` 会将消息转发给调用方。

## 1.3、 `MQ` 的分类

### 1.3.1、 `ActiveMQ` 

优点：单机吞吐量万级，时效性毫秒级，可用性高，基于主从架构实现高可用性，消息可靠性高，较低的概率丢失数据。

缺点：官方社区目前对 `ActiveMQ 5.X` 维护较少，高吞吐量场景较少使用

### 1.3.2、 `Kafka` 

​	`Kafka` 主要作为大数据的消息中间件使用，目前已被 `LinkedIn` 、`Uber` 、`Twitter` 、`Netflix` 等公司采纳。

优点：性能卓越，单机写入 `TPS` 大约在百万条/秒，时效性为毫秒级别，分布式，消费者使用 `pull` 方式获取消息，消息有序，日志方面比较成熟。

缺点：单机超过64个队列/分区， `Load` 会发生明显的飚高现象，队列越多， `load` 越高，发送消息的响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台宕机后，就会产生消息乱序，社区更新较慢。

### 1.3.3、 `RocketMQ` 

​	出自阿里巴巴的开源产品，使用 `Java` 语言实现，设计时参考了 `Kafka` ，并进行了接一些改进，被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理， `binglog` 分发等场景。

优点：单机吞吐量十万级，可用性非常高，分布式架构，消息可以做到0丢失， `MQ` 功能较为完善，分布式，扩展性好，支持十亿级别消息堆积，不会因为堆积导致性能下降，源码是 `Java` ，可以进行自定义开发。

缺点：支持的客户端语言不多，目前是 `java` 和 `c++` ，其中 `c++` 不成熟；社区活跃度一般，没有在 `MQ` 核心中去实现 `JMS` 等接口，有些系统要迁移需要修改大量代码。

### 1.3.4、 `RabbitMQ` 

​	2007年发布，是一个在 `AMOP` （高级消息队列协议）基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。

优点：由于 `erlang` 的高并发特性，性能较好；吞吐量达到万级， `MQ` 功能比较完备、健壮、稳定、易用、跨平台、支持多种语言。管理界面功能齐全，社区活跃度高，更新频率较高。

缺点：商业版需要收费，学习成本高。

## 2、 `RabbitMQ` 

### 2.1、概念

​	`RabbitMQ` 是一个中间件：它接收并转发消息，类似快递站点。它不处理消息，只接收、储存和转发消息数据。

### 2.2、四大核心概念

- 生产者：成神数据发送消息的程序是生产者
- 交换机：接收来自生产者的消息，并将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或是吧消息丢弃，需要有交换机的类型决定。
- 队列：队列是 `RabbitMQ` 内部使用的一种数据结构，尽管消息流经 `RabbitMQ` 和应用程序，但是它们只能储存在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列中接收数据。这就是我们使用队列的方式。
- 消费者：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又可以是消费者。

### 2.3、 `RabbitMQ` 核心部分

![rabbitMQ核心部分1（1](photo\1、rabbitMQ核心部分1（1）.png)

![rabbitMQ核心部分2（1）](photo\2、rabbitMQ核心部分2（1）.png)

![rabbitMQ核心部分3（1）](photo\3、rabbitMQ核心部分3（1）.png)

### 2.4、名词介绍

![rabbitMQ工作原理](photo\4、rabbitMQ工作原理（1）.png)

- `Broker` ：接收和分发消息的应用， `RabbitMQ Server` 就是 `Message Broker` 
- `Virtual host` ：出于多租户和安全因素设计的，把 `AMQP` 的基本组件划分到一个虚拟的分组中，类似于网络中的 `namespace` 概念。当多个不同的用户使用同一个 `RabbitMQ Server` 提供的服务时，可以划分出多个 `vhost` 每个用户在自己的 `vhost` 创建 `exchange/queue` 等。
- `Connection` ：`publisher/consumer` 和 `broker` 之间的 `TCP` 连接
- `Channel` ：是在 `connection` 内部简历的逻辑连接，如果应用程序支持多线程，通常每个 `thread` 创建单独的 `channel` 通讯， `AMQP method` 包含了 `channel id` 帮助客户端和 `message broker` 识别 `channel` ，所以 `channel` 之间是完全隔离的。 `channel` 作为轻量级的 `connection` 极大减少了系统简历 `TCP connection` 的开销。
- `Exchange` ：消息到达 `broker` 的第一站，根据分发规则，匹配查询表中的 `routing key` ，分发消息到 `queue` 中去。常用的类型有： `direct(point-to-point),topic(publish-subscribe) and fanout(multicast)` 。
- `Queue` ：消息最终被送到这里等待被消费者取走
- `Binding` ：`Exchange` 和 `queue` 之间的虚拟连接， `binding` 中可以包含 `routing key` ，`Binding` 信息被保存到 `exchange` 中的查询表中，用于 `message` 的分发依据。

### 2.5、安装

#### 2.5.1、官网下载上传

