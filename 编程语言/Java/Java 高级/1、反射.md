# 类加载器

## 类加载器结构 

![image-20211216111304198](E:\workspace\Notes&Files\learning_notes\编程语言\Java\Java 高级\photo\1、类加载器结构(1).png) 

* `BootstrapClassLoader` ：启动类类加载器由 `C++` 实现，在代码中获取使用它加载的类的类加载器（即执行 `getClassLoader()` 方法）会返回 `null` 。它用来加载`<JAVA_HOME>/jre/lib`路径,`-Xbootclasspath`参数指定的路径以`<JAVA_HOME>/jre/classes`中的类。
* `ExtClassLoader` ：拓展类类加载器，它用来加载`<JAVA_HOME>/jre/lib/ext`路径以及`java.ext.dirs`系统变量指定的类路径下的类。
* `AppClassLoader` ：应用程序类类加载器，它主要加载应用程序`ClassPath`下的类（包含`jar`包中的类）。它是`java`应用程序**默认**的类加载器。
* 用户自定义类加载器：用户根据自定义需求，自由的定制加载的逻辑，继承`AppClassLoader`，仅仅覆盖`findClass()` 时将继续遵守双亲委派模型，也可以同时覆盖 `loadClass()` 方法破坏双亲委派模型。
* `ThreadContextClassLoader` ：线程上下文加载器，它不是一个新的类型，更像一个类加载器的角色，`ThreadContextClassLoader`可以是上述类加载器的任意一种，但往往是`AppClassLoader`，作用我们后面再说。

## 双亲委派机制

### 概述原理


> 双亲委派模型：在使用子级类加载器时，子级会首先调用父级的 `loadClass()` 方法来尝试加载类，加载失败后才会使用子级的类加载器进行加载，由此每当加载类时，都会使用最顶级的类加载器来首先尝试加载类。

<img src="E:\workspace\Notes&Files\learning_notes\编程语言\Java\Java 高级\photo\3、类加载器双亲委派机制(1).png" alt="image-20211216114146502" style="zoom:80%;" /> 

那么，为什么要使用双亲委派机制呢？

> 在加载一个类时优先委派给父类加载器，这样保证不会出现类被重复加载，也保证了java一些基础类可以稳定的存在，不会被用户自定义类顶替掉。



### 双亲委派机制的缺陷

双亲委派模型并不是完美的，在一些场景下会出现一些比较难解决的问题，举个例子，在使用 `SPI` 的时候， `ServiceLoader` 是通过 `BootStrap `类加载器加载的，在执行到加载用户编写的扩展类的时候，如果使用当前类的类加载器，是肯定无法加载到用户编写的类的，这个时候就无法继续执行了，所以这个时候就需要使用 `Thread` 的上下文类加载器，查看源码的时候我们就发现，在用户不主动传递 `ClassLoader` 的时候，会获取当前上下文类加载器，这样应用程序才能正常的执行。

- 为了理解上面这段话，首先先用代码测试一下这个 `ServiceLoader` 类到底使用什么类加载器加载的。

![image-20211216155110615](E:\workspace\Notes&Files\learning_notes\编程语言\Java\Java 高级\photo\5、ServiceLoader获取类加载器(1).png) 

`ServiceLoader` 类确实是由 `BootStrap` 类加载器加载的，上面所说的上下文加载器则在`ServiceLoader` 源码中可以找到。

```java
public static <S> ServiceLoader<S> load(Class<S> service) {
    // 获取上下文加载器，使用此加载器来加载指定类
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}
```

- 为什么需要使用获取到的上下文类加载器来加载指定的类呢？

**程序运行过程中要用到的类，通过当前类加载器的自动加载，加载不到（不在当前类加载器的类资源管辖范围），如果要使用这个类，必须指定一个能够加载这个类的加载器去加载，而怎么获取这个加载器是个问题。
 程序都是在线程中执行，那么从线程的上下文中去拿最合理，所以就诞生了线程上下文类加载器，这个加载器的是非自动加载，即通过 `forName` 或者 `loadClass` 的方式去加载类。** 

当前 `ServiceLoader` 类是由 `BootStrap` 类加载器进行加载的，在上方描述中已有解释，此类加载器只能加载`<JAVA_HOME>/jre/lib` 路径,`-Xbootclasspath`参数指定的路径以`<JAVA_HOME>/jre/classes`中的类。因此要想在高层中加载类（或实例化）低层的类时，我们就需要获取上下文类加载器或者使用指定的类加载器来加载当前类。

引用—— [SPI与线程上下文类加载器](https://www.jianshu.com/p/304cb533ba2d) 

### `Launcher` 类

在虚拟机启动的时候会初始化`BootstrapClassLoader`，然后在`Launcher`类中去加载`ExtClassLoader`、`AppClassLoader`，并将`AppClassLoader`的`parent`设置为`ExtClassLoader`，并设置线程上下文类加载器。

`sun.misc.Laucher` 类是 `java` 的入口，在启动 `java` 应用的时候会首先创建 `Launcher` 类，创建 `Launcher` 类的时候会准备应用程序运行中需要的类加载器。 

`Launcher` 作为 `JAVA` 应用的入口，根据双亲委派模型，`Laucher`是由`JVM`创建的，它类加载器应该是`BootStrapClassLoader` 。

![image-20211216114539060](E:\workspace\Notes&Files\learning_notes\编程语言\Java\Java 高级\photo\2、Launcher类的类加载器(1).png) 

> 因为 `BootStrapClassLoader` 是由 `c++` 实现，在 `java` 中无法获取到对象，所以返回 `null` 。

- 因此我们查看一个普通类的类加载及其父类加载器分别是什么

![image-20211216115058851](E:\workspace\Notes&Files\learning_notes\编程语言\Java\Java 高级\photo\4、类加载器关系(1).png) 

由此可以看到类加载器的层级关系为 `AppClassLoader < ExtClassLoader < BoorStrapClassLoader` 

- 那我们在 `ServiceLoader` 获取的上下文类加载器到底是这三个加载器中的哪一个呢？

```java
public Launcher() {
    Launcher.ExtClassLoader var1;
    try {
        // 获取到ext类加载器
        var1 = Launcher.ExtClassLoader.getExtClassLoader();
    } catch (IOException var10) {
        throw new InternalError("Could not create extension class loader", var10);
    }

    try {
        // 将ext类加载器作为父加载器获取到app类加载器
        this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
    } catch (IOException var9) {
        throw new InternalError("Could not create application class loader", var9);
    }

    // 将当前线程的上下文加载器设置为 AppClassLoader
    Thread.currentThread().setContextClassLoader(this.loader);
    
    // other code ...

}
```

上面的代码中是用户加载 `main` 方法的 `Launcher` 类中的构造方法，可以看到先获取 `ExtClassLoader` 然后作为父加载器获取到 `AppClassLoader` 最后将 `AppClassLoader` 设置为当前线程的上下文加载器。由此可知，在 `ServiceLoader` 类中获取到的上下文类加载器即为 `AppClassLoader` 。



> 现在又引出一个问题—— `SPI` 和 `ServiceLoader` 到底是什么？用来做什么的？



## `SPI` 



### 为什么使用 `SPI` 

面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。 `java spi` 就是提供这样的一个机制：为某个接口寻找服务实现的机制。这有点类似 `IOC` 的思想，将装配的控制权移到了程序之外。

### `SPI` 概述

现在我们的程序分为实现方（服务）和使用方（客户），在这两方中引入“接口”。此时这个接口有三种情况，一种即是接口归实现方，接口是实现方中的一部分；另一种则是接口归使用方，接口是使用方的一部分；最后即是接口处于独立的包中。



- 当接口归实现方

![image-20211216172000346](E:\workspace\Notes&Files\learning_notes\编程语言\Java\Java 高级\photo\6、SPI思想-API(1).png) 

看起来很眼熟，这不就是 `API (Application Programming Interface)` 。而 `API` 有以下特点：

1. 概念上接近实现方
2. 位于实现方所在的包中
3. 实现和接口在一个包中



- 当接口归使用方

![image-20211216173511800](E:\workspace\Notes&Files\learning_notes\编程语言\Java\Java 高级\photo\7、SPI思想-SPI(1).png) 

对于类似这种情况的接口将其称为 `SPI (service provider interface)` ， `SPI` 的规则如下：

1. 概念上更依赖调用方。
2. 组织上位于调用方所在的包中。
3. 实现位于独立的包中 （也可以认为在实现方包中）。
4. 常见的例子是：插件模式的插件。



- 接口是独立的包

如果一个“接口”在一个上下文是 `API` ，在另一个上下文是 `SPI` ，就可以成为一个独立的包，不管是 `SPI` 或 `API` ，接口都是可以组织到独立的“包”中。



### `SPI` 实现

概念通常都十分晦涩，手写一个 `SPI` 接口用于加深记忆。

需求：实现一个搜索功能，分别可以从文件和数据库中搜索文件。

- 实现方

接口类 `Search` 

```java
public interface Search {

    public List<String> searchDoc(String keyword);

}
```

实现类 `FileSearch` 

```java
public class FileSearch implements Search{
    @Override
    public List<String> searchDoc(String keyword) {
        System.out.println("file search by keyword :"+keyword);
        return null;
    }
}
```

实现类 `DatabaseSearch` 

```java
public class DatabaseSearch implements Search {
    @Override
    public List<String> searchDoc(String keyword) {
        System.out.println("database search by keyword :" + keyword);
        return null;
    }
}
```

`resources` 文件夹下创建文件 `META-INF/services` ，在创建好的文件夹创建一个名为搜索接口全限定类名的文件，在其中写入具体我们要使用的实现类的全限定类名。

![image-20211216174656088](E:\workspace\Notes&Files\learning_notes\编程语言\Java\Java 高级\photo\8、SPI实践-创建文件(1).png) 

文件内容

```
com.mochen.advance.spi.FileSearch
```

> 至此，实现方的类和方法已经完成

- 调用方

直接使用测试方法进行测试

```java
public static void main(String[] args) {
    // 加载指定接口类
    ServiceLoader<Search> service = ServiceLoader.load(Search.class);
    Iterator<Search> iterator = service.iterator();
    // 遍历实现的类
    while (iterator.hasNext()){
        Search next = iterator.next();
        // 指定接口类中的方法
        next.searchDoc("MoChen");
    }
}
```

- 测试结果

![image-20211216175142024](E:\workspace\Notes&Files\learning_notes\编程语言\Java\Java 高级\photo\9、SPI实践-结果(1).png) 

> 当使用在 `resources` 下的配置文件中加入多个实现类，此处也会循环执行多次。



- 为什么要在 `resources` 下创建指定文件夹？

![image-20211216175319714](E:\workspace\Notes&Files\learning_notes\编程语言\Java\Java 高级\photo\10、SPI实践-文件夹路径(1).png) 

> 此路径是直接写死在 `ServiceLoader` 中的。



